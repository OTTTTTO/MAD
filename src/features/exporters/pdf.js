/**
 * PDF å¯¼å‡ºå™¨
 * 
 * ä½¿ç”¨ PDFKit ç”Ÿæˆæ ¼å¼åŒ–çš„ PDF æ–‡æ¡£
 * 
 * @module exporters/pdf
 * @version 1.0.0
 */

const PDFDocument = require('pdfkit');
const fs = require('fs');

/**
 * å¯¼å‡ºè®¨è®ºä¸º PDF
 */
async function exportToPDF(discussion, options = {}) {
  const {
    outputPath = null,
    includeMetadata = true,
    includeStats = true
  } = options;

  return new Promise((resolve, reject) => {
    try {
      // åˆ›å»º PDF æ–‡æ¡£
      const doc = new PDFDocument({
        size: 'A4',
        margins: {
          top: 50,
          bottom: 50,
          left: 50,
          right: 50
        },
        info: {
          Title: discussion.topic || 'Discussion',
          Author: 'MAD - Multi-Agent Discussion',
          Subject: 'Discussion Export',
          Creator: 'MAD v2.1.0'
        }
      });

      // æ”¶é›† PDF æ•°æ®
      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(chunks);

        // å¦‚æœæŒ‡å®šäº†è¾“å‡ºè·¯å¾„ï¼Œä¿å­˜åˆ°æ–‡ä»¶
        if (outputPath) {
          fs.writeFileSync(outputPath, pdfBuffer);
        }

        resolve({
          data: pdfBuffer,
          size: pdfBuffer.length,
          path: outputPath
        });
      });

      // æ·»åŠ å†…å®¹
      addContent(doc, discussion, { includeMetadata, includeStats });

      // ç»“æŸæ–‡æ¡£
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * æ·»åŠ å†…å®¹åˆ° PDF
 */
function addContent(doc, discussion, options) {
  const { includeMetadata, includeStats } = options;

  // æ ‡é¢˜
  doc.fontSize(24)
     .fillColor('#1e293b')
     .text(discussion.topic || 'Discussion', { align: 'center' });
  
  doc.moveDown();

  // å…ƒæ•°æ®
  if (includeMetadata) {
    doc.fontSize(10)
       .fillColor('#64748b')
       .text(`Discussion ID: ${discussion.id}`, { align: 'center' })
       .text(`Status: ${getStatusLabel(discussion.status)}`, { align: 'center' })
       .text(`Created: ${new Date(discussion.createdAt).toLocaleString('zh-CN')}`, { align: 'center' });

    if (discussion.endedAt) {
      doc.text(`Ended: ${new Date(discussion.endedAt).toLocaleString('zh-CN')}`, { align: 'center' });
    }

    doc.moveDown();
  }

  // åˆ†éš”çº¿
  doc.moveTo(50, doc.y)
     .lineTo(545, doc.y)
     .strokeColor('#cbd5e1')
     .lineWidth(1)
     .stroke();

  doc.moveDown();

  // ç»Ÿè®¡ä¿¡æ¯
  if (includeStats && discussion.stats) {
    doc.fontSize(14)
       .fillColor('#334155')
       .text('ç»Ÿè®¡ä¿¡æ¯', { underline: true });

    doc.fontSize(10)
       .fillColor('#475569')
       .text(`æ¶ˆæ¯æ€»æ•°: ${discussion.stats.messageCount || 0}`)
       .text(`å‚ä¸ Agent: ${discussion.stats.participantCount || 0}`)
       .text(`è®¨è®ºè½®æ¬¡: ${discussion.stats.roundCount || 0}`)
       .text(`æŒç»­æ—¶é—´: ${formatDuration(discussion.stats.duration)}`);

    doc.moveDown();
  }

  // å‚ä¸è€…åˆ—è¡¨
  if (discussion.participants && discussion.participants.length > 0) {
    doc.fontSize(14)
       .fillColor('#334155')
       .text('å‚ä¸è€…', { underline: true });

    doc.fontSize(10)
       .fillColor('#475569');

    discussion.participants.forEach(p => {
      const line = `${p.emoji || 'ğŸ¤–'} ${p.role || p.name}`;
      doc.text(line, { continued: false });
    });

    doc.moveDown();
  }

  // åˆ†éš”çº¿
  doc.moveTo(50, doc.y)
     .lineTo(545, doc.y)
     .strokeColor('#cbd5e1')
     .lineWidth(1)
     .stroke();

  doc.moveDown();

  // æ¶ˆæ¯åˆ—è¡¨
  doc.fontSize(14)
     .fillColor('#334155')
     .text('è®¨è®ºè®°å½•', { underline: true });

  doc.moveDown();

  if (discussion.messages && discussion.messages.length > 0) {
    let currentRole = null;

    discussion.messages.forEach((msg, index) => {
      // è§’è‰²åç§°
      if (msg.role !== currentRole) {
        doc.fontSize(12)
           .fillColor('#0f172a')
           .text(`${msg.emoji || 'ğŸ¤–'} ${msg.role}`, { continued: false });
        currentRole = msg.role;
      }

      // æ¶ˆæ¯å†…å®¹
      const content = msg.content || '';
      const lines = doc.widthOfString(content) > 495 ? wrapText(content, 495, doc) : [content];

      doc.fontSize(10)
         .fillColor('#334155')
         .list(lines);

      // æ—¶é—´æˆ³
      doc.fontSize(8)
         .fillColor('#94a3b8')
         .text(`${new Date(msg.timestamp).toLocaleString('zh-CN')}`)
         .moveDown();
    });
  } else {
    doc.fontSize(10)
       .fillColor('#94a3b8')
       .text('æš‚æ— æ¶ˆæ¯');
  }

  // é¡µè„š
  const pageCount = doc.bufferedPageRange().count;
  for (let i = 0; i < pageCount; i++) {
    doc.switchToPage(i);
    doc.fontSize(8)
       .fillColor('#94a3b8')
       .text(
         `Generated by MAD v2.1.0 - Page ${i + 1} of ${pageCount}`,
         50,
         doc.page.height - 30,
         { align: 'center' }
       );
  }
}

/**
 * ç®€å•çš„æ–‡æœ¬æ¢è¡Œ
 */
function wrapText(text, maxWidth, doc) {
  const words = text.split('');
  const lines = [];
  let currentLine = '';

  words.forEach(word => {
    const testLine = currentLine + word;
    const width = doc.widthOfString(testLine);

    if (width < maxWidth) {
      currentLine = testLine;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  });

  if (currentLine) {
    lines.push(currentLine);
  }

  return lines;
}

/**
 * è·å–çŠ¶æ€æ ‡ç­¾
 */
function getStatusLabel(status) {
  const labels = {
    'initializing': 'åˆå§‹åŒ–ä¸­',
    'active': 'è¿›è¡Œä¸­',
    'concluding': 'æ€»ç»“ä¸­',
    'ended': 'å·²ç»“æŸ'
  };
  return labels[status] || status;
}

/**
 * æ ¼å¼åŒ–æŒç»­æ—¶é—´
 */
function formatDuration(ms) {
  if (!ms) return 'æœªçŸ¥';

  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours} å°æ—¶ ${minutes % 60} åˆ†é’Ÿ`;
  } else if (minutes > 0) {
    return `${minutes} åˆ†é’Ÿ ${seconds % 60} ç§’`;
  } else {
    return `${seconds} ç§’`;
  }
}

module.exports = {
  exportToPDF
};
